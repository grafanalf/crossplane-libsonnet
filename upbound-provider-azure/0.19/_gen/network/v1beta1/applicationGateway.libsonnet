{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='applicationGateway', url='', help='"ApplicationGateway is the Schema for the ApplicationGateways API. Manages an Application Gateway."'),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of ApplicationGateway', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'network.azure.upbound.io/v1beta1',
    kind: 'ApplicationGateway',
  } + self.metadata.withName(name=name) + self.metadata.withAnnotations(annotations={
    'tanka.dev/namespaced': 'false',
  }),
  '#spec':: d.obj(help='"ApplicationGatewaySpec defines the desired state of ApplicationGateway"'),
  spec: {
    '#forProvider':: d.obj(help=''),
    forProvider: {
      '#authenticationCertificate':: d.obj(help='"One or more authentication_certificate blocks as defined below."'),
      authenticationCertificate: {
        '#dataSecretRef':: d.obj(help='"The contents of the Authentication Certificate which should be used."'),
        dataSecretRef: {
          '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { dataSecretRef+: { key: key } },
          '#withName':: d.fn(help='"Name of the secret."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { dataSecretRef+: { name: name } },
          '#withNamespace':: d.fn(help='"Namespace of the secret."', args=[d.arg(name='namespace', type=d.T.string)]),
          withNamespace(namespace): { dataSecretRef+: { namespace: namespace } },
        },
        '#withName':: d.fn(help='"The Name of the Authentication Certificate to use."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#autoscaleConfiguration':: d.obj(help='"A autoscale_configuration block as defined below."'),
      autoscaleConfiguration: {
        '#withMaxCapacity':: d.fn(help='"Maximum capacity for autoscaling. Accepted values are in the range 2 to 125."', args=[d.arg(name='maxCapacity', type=d.T.number)]),
        withMaxCapacity(maxCapacity): { maxCapacity: maxCapacity },
        '#withMinCapacity':: d.fn(help='"Minimum capacity for autoscaling. Accepted values are in the range 0 to 100."', args=[d.arg(name='minCapacity', type=d.T.number)]),
        withMinCapacity(minCapacity): { minCapacity: minCapacity },
      },
      '#backendAddressPool':: d.obj(help='"One or more backend_address_pool blocks as defined below."'),
      backendAddressPool: {
        '#withFqdns':: d.fn(help="\"A list of FQDN's which should be part of the Backend Address Pool.\"", args=[d.arg(name='fqdns', type=d.T.array)]),
        withFqdns(fqdns): { fqdns: if std.isArray(v=fqdns) then fqdns else [fqdns] },
        '#withFqdnsMixin':: d.fn(help="\"A list of FQDN's which should be part of the Backend Address Pool.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='fqdns', type=d.T.array)]),
        withFqdnsMixin(fqdns): { fqdns+: if std.isArray(v=fqdns) then fqdns else [fqdns] },
        '#withIpAddresses':: d.fn(help='"A list of IP Addresses which should be part of the Backend Address Pool."', args=[d.arg(name='ipAddresses', type=d.T.array)]),
        withIpAddresses(ipAddresses): { ipAddresses: if std.isArray(v=ipAddresses) then ipAddresses else [ipAddresses] },
        '#withIpAddressesMixin':: d.fn(help='"A list of IP Addresses which should be part of the Backend Address Pool."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ipAddresses', type=d.T.array)]),
        withIpAddressesMixin(ipAddresses): { ipAddresses+: if std.isArray(v=ipAddresses) then ipAddresses else [ipAddresses] },
        '#withName':: d.fn(help='"The name of the Backend Address Pool."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#backendHttpSettings':: d.obj(help='"One or more backend_http_settings blocks as defined below."'),
      backendHttpSettings: {
        '#authenticationCertificate':: d.obj(help='"One or more authentication_certificate blocks."'),
        authenticationCertificate: {
          '#withName':: d.fn(help='"The Name of the URL Path Map."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
        },
        '#connectionDraining':: d.obj(help='"A connection_draining block as defined below."'),
        connectionDraining: {
          '#withDrainTimeoutSec':: d.fn(help='"The number of seconds connection draining is active. Acceptable values are from 1 second to 3600 seconds."', args=[d.arg(name='drainTimeoutSec', type=d.T.number)]),
          withDrainTimeoutSec(drainTimeoutSec): { drainTimeoutSec: drainTimeoutSec },
          '#withEnabled':: d.fn(help='"Is the Web Application Firewall be enabled?"', args=[d.arg(name='enabled', type=d.T.boolean)]),
          withEnabled(enabled): { enabled: enabled },
        },
        '#withAffinityCookieName':: d.fn(help='"The name of the affinity cookie."', args=[d.arg(name='affinityCookieName', type=d.T.string)]),
        withAffinityCookieName(affinityCookieName): { affinityCookieName: affinityCookieName },
        '#withAuthenticationCertificate':: d.fn(help='"One or more authentication_certificate blocks."', args=[d.arg(name='authenticationCertificate', type=d.T.array)]),
        withAuthenticationCertificate(authenticationCertificate): { authenticationCertificate: if std.isArray(v=authenticationCertificate) then authenticationCertificate else [authenticationCertificate] },
        '#withAuthenticationCertificateMixin':: d.fn(help='"One or more authentication_certificate blocks."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='authenticationCertificate', type=d.T.array)]),
        withAuthenticationCertificateMixin(authenticationCertificate): { authenticationCertificate+: if std.isArray(v=authenticationCertificate) then authenticationCertificate else [authenticationCertificate] },
        '#withConnectionDraining':: d.fn(help='"A connection_draining block as defined below."', args=[d.arg(name='connectionDraining', type=d.T.array)]),
        withConnectionDraining(connectionDraining): { connectionDraining: if std.isArray(v=connectionDraining) then connectionDraining else [connectionDraining] },
        '#withConnectionDrainingMixin':: d.fn(help='"A connection_draining block as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='connectionDraining', type=d.T.array)]),
        withConnectionDrainingMixin(connectionDraining): { connectionDraining+: if std.isArray(v=connectionDraining) then connectionDraining else [connectionDraining] },
        '#withCookieBasedAffinity':: d.fn(help='"Is Cookie-Based Affinity enabled? Possible values are Enabled and Disabled."', args=[d.arg(name='cookieBasedAffinity', type=d.T.string)]),
        withCookieBasedAffinity(cookieBasedAffinity): { cookieBasedAffinity: cookieBasedAffinity },
        '#withHostName':: d.fn(help='"Host header to be sent to the backend servers. Cannot be set if pick_host_name_from_backend_address is set to true."', args=[d.arg(name='hostName', type=d.T.string)]),
        withHostName(hostName): { hostName: hostName },
        '#withName':: d.fn(help='"The name of the Backend HTTP Settings Collection."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withPath':: d.fn(help='"The Path which should be used as a prefix for all HTTP requests."', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { path: path },
        '#withPickHostNameFromBackendAddress':: d.fn(help='"Whether host header should be picked from the host name of the backend server. Defaults to false."', args=[d.arg(name='pickHostNameFromBackendAddress', type=d.T.boolean)]),
        withPickHostNameFromBackendAddress(pickHostNameFromBackendAddress): { pickHostNameFromBackendAddress: pickHostNameFromBackendAddress },
        '#withPort':: d.fn(help='"The port which should be used for this Backend HTTP Settings Collection."', args=[d.arg(name='port', type=d.T.number)]),
        withPort(port): { port: port },
        '#withProbeName':: d.fn(help='"The name of an associated HTTP Probe."', args=[d.arg(name='probeName', type=d.T.string)]),
        withProbeName(probeName): { probeName: probeName },
        '#withProtocol':: d.fn(help='"The Protocol which should be used. Possible values are Http and Https."', args=[d.arg(name='protocol', type=d.T.string)]),
        withProtocol(protocol): { protocol: protocol },
        '#withRequestTimeout':: d.fn(help='"The request timeout in seconds, which must be between 1 and 86400 seconds."', args=[d.arg(name='requestTimeout', type=d.T.number)]),
        withRequestTimeout(requestTimeout): { requestTimeout: requestTimeout },
        '#withTrustedRootCertificateNames':: d.fn(help='"A list of trusted_root_certificate names."', args=[d.arg(name='trustedRootCertificateNames', type=d.T.array)]),
        withTrustedRootCertificateNames(trustedRootCertificateNames): { trustedRootCertificateNames: if std.isArray(v=trustedRootCertificateNames) then trustedRootCertificateNames else [trustedRootCertificateNames] },
        '#withTrustedRootCertificateNamesMixin':: d.fn(help='"A list of trusted_root_certificate names."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='trustedRootCertificateNames', type=d.T.array)]),
        withTrustedRootCertificateNamesMixin(trustedRootCertificateNames): { trustedRootCertificateNames+: if std.isArray(v=trustedRootCertificateNames) then trustedRootCertificateNames else [trustedRootCertificateNames] },
      },
      '#customErrorConfiguration':: d.obj(help='"One or more custom_error_configuration blocks as defined below."'),
      customErrorConfiguration: {
        '#withCustomErrorPageUrl':: d.fn(help='"Error page URL of the application gateway customer error."', args=[d.arg(name='customErrorPageUrl', type=d.T.string)]),
        withCustomErrorPageUrl(customErrorPageUrl): { customErrorPageUrl: customErrorPageUrl },
        '#withStatusCode':: d.fn(help='"Status code of the application gateway customer error. Possible values are HttpStatus403 and HttpStatus502"', args=[d.arg(name='statusCode', type=d.T.string)]),
        withStatusCode(statusCode): { statusCode: statusCode },
      },
      '#frontendIpConfiguration':: d.obj(help='"One or more frontend_ip_configuration blocks as defined below."'),
      frontendIpConfiguration: {
        '#publicIpAddressIdRef':: d.obj(help='"Reference to a PublicIP to populate publicIpAddressId."'),
        publicIpAddressIdRef: {
          '#policy':: d.obj(help='"Policies for referencing."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { publicIpAddressIdRef+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { publicIpAddressIdRef+: { policy+: { resolve: resolve } } },
          },
          '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { publicIpAddressIdRef+: { name: name } },
        },
        '#publicIpAddressIdSelector':: d.obj(help='"Selector for a PublicIP to populate publicIpAddressId."'),
        publicIpAddressIdSelector: {
          '#policy':: d.obj(help='"Policies for selection."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { publicIpAddressIdSelector+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { publicIpAddressIdSelector+: { policy+: { resolve: resolve } } },
          },
          '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference as the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
          withMatchControllerRef(matchControllerRef): { publicIpAddressIdSelector+: { matchControllerRef: matchControllerRef } },
          '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabels(matchLabels): { publicIpAddressIdSelector+: { matchLabels: matchLabels } },
          '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabelsMixin(matchLabels): { publicIpAddressIdSelector+: { matchLabels+: matchLabels } },
        },
        '#subnetIdRef':: d.obj(help='"Reference to a Subnet to populate subnetId."'),
        subnetIdRef: {
          '#policy':: d.obj(help='"Policies for referencing."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { subnetIdRef+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { subnetIdRef+: { policy+: { resolve: resolve } } },
          },
          '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { subnetIdRef+: { name: name } },
        },
        '#subnetIdSelector':: d.obj(help='"Selector for a Subnet to populate subnetId."'),
        subnetIdSelector: {
          '#policy':: d.obj(help='"Policies for selection."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { subnetIdSelector+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { subnetIdSelector+: { policy+: { resolve: resolve } } },
          },
          '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference as the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
          withMatchControllerRef(matchControllerRef): { subnetIdSelector+: { matchControllerRef: matchControllerRef } },
          '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabels(matchLabels): { subnetIdSelector+: { matchLabels: matchLabels } },
          '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabelsMixin(matchLabels): { subnetIdSelector+: { matchLabels+: matchLabels } },
        },
        '#withName':: d.fn(help='"The name of the Frontend IP Configuration."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withPrivateIpAddress':: d.fn(help='"The Private IP Address to use for the Application Gateway."', args=[d.arg(name='privateIpAddress', type=d.T.string)]),
        withPrivateIpAddress(privateIpAddress): { privateIpAddress: privateIpAddress },
        '#withPrivateIpAddressAllocation':: d.fn(help='"The Allocation Method for the Private IP Address. Possible values are Dynamic and Static."', args=[d.arg(name='privateIpAddressAllocation', type=d.T.string)]),
        withPrivateIpAddressAllocation(privateIpAddressAllocation): { privateIpAddressAllocation: privateIpAddressAllocation },
        '#withPrivateLinkConfigurationName':: d.fn(help='"The name of the private link configuration to use for this frontend IP configuration."', args=[d.arg(name='privateLinkConfigurationName', type=d.T.string)]),
        withPrivateLinkConfigurationName(privateLinkConfigurationName): { privateLinkConfigurationName: privateLinkConfigurationName },
        '#withPublicIpAddressId':: d.fn(help='"The ID of a Public IP Address which the Application Gateway should use. The allocation method for the Public IP Address depends on the sku of this Application Gateway. Please refer to the Azure documentation for public IP addresses for details."', args=[d.arg(name='publicIpAddressId', type=d.T.string)]),
        withPublicIpAddressId(publicIpAddressId): { publicIpAddressId: publicIpAddressId },
        '#withSubnetId':: d.fn(help='"The ID of the Subnet."', args=[d.arg(name='subnetId', type=d.T.string)]),
        withSubnetId(subnetId): { subnetId: subnetId },
      },
      '#frontendPort':: d.obj(help='"One or more frontend_port blocks as defined below."'),
      frontendPort: {
        '#withName':: d.fn(help='"The name of the Frontend Port."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withPort':: d.fn(help='"The port used for this Frontend Port."', args=[d.arg(name='port', type=d.T.number)]),
        withPort(port): { port: port },
      },
      '#gatewayIpConfiguration':: d.obj(help='"One or more gateway_ip_configuration blocks as defined below."'),
      gatewayIpConfiguration: {
        '#subnetIdRef':: d.obj(help='"Reference to a Subnet in network to populate subnetId."'),
        subnetIdRef: {
          '#policy':: d.obj(help='"Policies for referencing."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { subnetIdRef+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { subnetIdRef+: { policy+: { resolve: resolve } } },
          },
          '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { subnetIdRef+: { name: name } },
        },
        '#subnetIdSelector':: d.obj(help='"Selector for a Subnet in network to populate subnetId."'),
        subnetIdSelector: {
          '#policy':: d.obj(help='"Policies for selection."'),
          policy: {
            '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
            withResolution(resolution): { subnetIdSelector+: { policy+: { resolution: resolution } } },
            '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
            withResolve(resolve): { subnetIdSelector+: { policy+: { resolve: resolve } } },
          },
          '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference as the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
          withMatchControllerRef(matchControllerRef): { subnetIdSelector+: { matchControllerRef: matchControllerRef } },
          '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabels(matchLabels): { subnetIdSelector+: { matchLabels: matchLabels } },
          '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
          withMatchLabelsMixin(matchLabels): { subnetIdSelector+: { matchLabels+: matchLabels } },
        },
        '#withName':: d.fn(help='"The Name of this Gateway IP Configuration."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withSubnetId':: d.fn(help='"The ID of the Subnet which the Application Gateway should be connected to."', args=[d.arg(name='subnetId', type=d.T.string)]),
        withSubnetId(subnetId): { subnetId: subnetId },
      },
      '#httpListener':: d.obj(help='"One or more http_listener blocks as defined below."'),
      httpListener: {
        '#customErrorConfiguration':: d.obj(help='"One or more custom_error_configuration blocks as defined below."'),
        customErrorConfiguration: {
          '#withCustomErrorPageUrl':: d.fn(help='"Error page URL of the application gateway customer error."', args=[d.arg(name='customErrorPageUrl', type=d.T.string)]),
          withCustomErrorPageUrl(customErrorPageUrl): { customErrorPageUrl: customErrorPageUrl },
          '#withStatusCode':: d.fn(help='"A list of allowed status codes for this Health Probe."', args=[d.arg(name='statusCode', type=d.T.string)]),
          withStatusCode(statusCode): { statusCode: statusCode },
        },
        '#withCustomErrorConfiguration':: d.fn(help='"One or more custom_error_configuration blocks as defined below."', args=[d.arg(name='customErrorConfiguration', type=d.T.array)]),
        withCustomErrorConfiguration(customErrorConfiguration): { customErrorConfiguration: if std.isArray(v=customErrorConfiguration) then customErrorConfiguration else [customErrorConfiguration] },
        '#withCustomErrorConfigurationMixin':: d.fn(help='"One or more custom_error_configuration blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='customErrorConfiguration', type=d.T.array)]),
        withCustomErrorConfigurationMixin(customErrorConfiguration): { customErrorConfiguration+: if std.isArray(v=customErrorConfiguration) then customErrorConfiguration else [customErrorConfiguration] },
        '#withFirewallPolicyId':: d.fn(help='"The ID of the Web Application Firewall Policy which should be used for this HTTP Listener."', args=[d.arg(name='firewallPolicyId', type=d.T.string)]),
        withFirewallPolicyId(firewallPolicyId): { firewallPolicyId: firewallPolicyId },
        '#withFrontendIpConfigurationName':: d.fn(help='"The Name of the Frontend IP Configuration used for this HTTP Listener."', args=[d.arg(name='frontendIpConfigurationName', type=d.T.string)]),
        withFrontendIpConfigurationName(frontendIpConfigurationName): { frontendIpConfigurationName: frontendIpConfigurationName },
        '#withFrontendPortName':: d.fn(help='"The Name of the Frontend Port use for this HTTP Listener."', args=[d.arg(name='frontendPortName', type=d.T.string)]),
        withFrontendPortName(frontendPortName): { frontendPortName: frontendPortName },
        '#withHostName':: d.fn(help="\"The Hostname which should be used for this HTTP Listener. Setting this value changes Listener Type to 'Multi site'.\"", args=[d.arg(name='hostName', type=d.T.string)]),
        withHostName(hostName): { hostName: hostName },
        '#withHostNames':: d.fn(help='"A list of Hostname(s) should be used for this HTTP Listener. It allows special wildcard characters."', args=[d.arg(name='hostNames', type=d.T.array)]),
        withHostNames(hostNames): { hostNames: if std.isArray(v=hostNames) then hostNames else [hostNames] },
        '#withHostNamesMixin':: d.fn(help='"A list of Hostname(s) should be used for this HTTP Listener. It allows special wildcard characters."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='hostNames', type=d.T.array)]),
        withHostNamesMixin(hostNames): { hostNames+: if std.isArray(v=hostNames) then hostNames else [hostNames] },
        '#withName':: d.fn(help='"The Name of the HTTP Listener."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withProtocol':: d.fn(help='"The Protocol to use for this HTTP Listener. Possible values are Http and Https."', args=[d.arg(name='protocol', type=d.T.string)]),
        withProtocol(protocol): { protocol: protocol },
        '#withRequireSni':: d.fn(help='"Should Server Name Indication be Required? Defaults to false."', args=[d.arg(name='requireSni', type=d.T.boolean)]),
        withRequireSni(requireSni): { requireSni: requireSni },
        '#withSslCertificateName':: d.fn(help='"The name of the associated SSL Certificate which should be used for this HTTP Listener."', args=[d.arg(name='sslCertificateName', type=d.T.string)]),
        withSslCertificateName(sslCertificateName): { sslCertificateName: sslCertificateName },
        '#withSslProfileName':: d.fn(help='"The name of the associated SSL Profile which should be used for this HTTP Listener."', args=[d.arg(name='sslProfileName', type=d.T.string)]),
        withSslProfileName(sslProfileName): { sslProfileName: sslProfileName },
      },
      '#identity':: d.obj(help='"An identity block as defined below."'),
      identity: {
        '#withIdentityIds':: d.fn(help='"Specifies a list of User Assigned Managed Identity IDs to be assigned to this Application Gateway."', args=[d.arg(name='identityIds', type=d.T.array)]),
        withIdentityIds(identityIds): { identityIds: if std.isArray(v=identityIds) then identityIds else [identityIds] },
        '#withIdentityIdsMixin':: d.fn(help='"Specifies a list of User Assigned Managed Identity IDs to be assigned to this Application Gateway."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='identityIds', type=d.T.array)]),
        withIdentityIdsMixin(identityIds): { identityIds+: if std.isArray(v=identityIds) then identityIds else [identityIds] },
        '#withType':: d.fn(help='"Specifies the type of Managed Service Identity that should be configured on this Application Gateway. Only possible value is UserAssigned."', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { type: type },
      },
      '#privateLinkConfiguration':: d.obj(help='"One or more private_link_configuration blocks as defined below."'),
      privateLinkConfiguration: {
        '#ipConfiguration':: d.obj(help='"One or more ip_configuration blocks as defined below."'),
        ipConfiguration: {
          '#subnetIdRef':: d.obj(help='"Reference to a Subnet to populate subnetId."'),
          subnetIdRef: {
            '#policy':: d.obj(help='"Policies for referencing."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { subnetIdRef+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { subnetIdRef+: { policy+: { resolve: resolve } } },
            },
            '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { subnetIdRef+: { name: name } },
          },
          '#subnetIdSelector':: d.obj(help='"Selector for a Subnet to populate subnetId."'),
          subnetIdSelector: {
            '#policy':: d.obj(help='"Policies for selection."'),
            policy: {
              '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
              withResolution(resolution): { subnetIdSelector+: { policy+: { resolution: resolution } } },
              '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
              withResolve(resolve): { subnetIdSelector+: { policy+: { resolve: resolve } } },
            },
            '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference as the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
            withMatchControllerRef(matchControllerRef): { subnetIdSelector+: { matchControllerRef: matchControllerRef } },
            '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { subnetIdSelector+: { matchLabels: matchLabels } },
            '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { subnetIdSelector+: { matchLabels+: matchLabels } },
          },
          '#withName':: d.fn(help='"The Name of the URL Path Map."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withPrimary':: d.fn(help='"Is this the Primary IP Configuration?"', args=[d.arg(name='primary', type=d.T.boolean)]),
          withPrimary(primary): { primary: primary },
          '#withPrivateIpAddress':: d.fn(help='"The Static IP Address which should be used."', args=[d.arg(name='privateIpAddress', type=d.T.string)]),
          withPrivateIpAddress(privateIpAddress): { privateIpAddress: privateIpAddress },
          '#withPrivateIpAddressAllocation':: d.fn(help='"The allocation method used for the Private IP Address. Possible values are Dynamic and Static."', args=[d.arg(name='privateIpAddressAllocation', type=d.T.string)]),
          withPrivateIpAddressAllocation(privateIpAddressAllocation): { privateIpAddressAllocation: privateIpAddressAllocation },
          '#withSubnetId':: d.fn(help='"The ID of the subnet the private link configuration should connect to."', args=[d.arg(name='subnetId', type=d.T.string)]),
          withSubnetId(subnetId): { subnetId: subnetId },
        },
        '#withIpConfiguration':: d.fn(help='"One or more ip_configuration blocks as defined below."', args=[d.arg(name='ipConfiguration', type=d.T.array)]),
        withIpConfiguration(ipConfiguration): { ipConfiguration: if std.isArray(v=ipConfiguration) then ipConfiguration else [ipConfiguration] },
        '#withIpConfigurationMixin':: d.fn(help='"One or more ip_configuration blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ipConfiguration', type=d.T.array)]),
        withIpConfigurationMixin(ipConfiguration): { ipConfiguration+: if std.isArray(v=ipConfiguration) then ipConfiguration else [ipConfiguration] },
        '#withName':: d.fn(help='"The name of the private link configuration."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#probe':: d.obj(help='"One or more probe blocks as defined below."'),
      probe: {
        '#match':: d.obj(help='"A match block as defined above."'),
        match: {
          '#withBody':: d.fn(help='"A snippet from the Response Body which must be present in the Response."', args=[d.arg(name='body', type=d.T.string)]),
          withBody(body): { body: body },
          '#withStatusCode':: d.fn(help='"A list of allowed status codes for this Health Probe."', args=[d.arg(name='statusCode', type=d.T.array)]),
          withStatusCode(statusCode): { statusCode: if std.isArray(v=statusCode) then statusCode else [statusCode] },
          '#withStatusCodeMixin':: d.fn(help='"A list of allowed status codes for this Health Probe."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='statusCode', type=d.T.array)]),
          withStatusCodeMixin(statusCode): { statusCode+: if std.isArray(v=statusCode) then statusCode else [statusCode] },
        },
        '#withHost':: d.fn(help='"The Hostname used for this Probe. If the Application Gateway is configured for a single site, by default the Host name should be specified as ‘127.0.0.1’, unless otherwise configured in custom probe. Cannot be set if pick_host_name_from_backend_http_settings is set to true."', args=[d.arg(name='host', type=d.T.string)]),
        withHost(host): { host: host },
        '#withInterval':: d.fn(help='"The Interval between two consecutive probes in seconds. Possible values range from 1 second to a maximum of 86,400 seconds."', args=[d.arg(name='interval', type=d.T.number)]),
        withInterval(interval): { interval: interval },
        '#withMatch':: d.fn(help='"A match block as defined above."', args=[d.arg(name='match', type=d.T.array)]),
        withMatch(match): { match: if std.isArray(v=match) then match else [match] },
        '#withMatchMixin':: d.fn(help='"A match block as defined above."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='match', type=d.T.array)]),
        withMatchMixin(match): { match+: if std.isArray(v=match) then match else [match] },
        '#withMinimumServers':: d.fn(help='"The minimum number of servers that are always marked as healthy. Defaults to 0."', args=[d.arg(name='minimumServers', type=d.T.number)]),
        withMinimumServers(minimumServers): { minimumServers: minimumServers },
        '#withName':: d.fn(help='"The Name of the Probe."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withPath':: d.fn(help='"The Path used for this Probe."', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { path: path },
        '#withPickHostNameFromBackendHttpSettings':: d.fn(help='"Whether the host header should be picked from the backend HTTP settings. Defaults to false."', args=[d.arg(name='pickHostNameFromBackendHttpSettings', type=d.T.boolean)]),
        withPickHostNameFromBackendHttpSettings(pickHostNameFromBackendHttpSettings): { pickHostNameFromBackendHttpSettings: pickHostNameFromBackendHttpSettings },
        '#withPort':: d.fn(help='"Custom port which will be used for probing the backend servers. The valid value ranges from 1 to 65535. In case not set, port from HTTP settings will be used. This property is valid for Standard_v2 and WAF_v2 only."', args=[d.arg(name='port', type=d.T.number)]),
        withPort(port): { port: port },
        '#withProtocol':: d.fn(help='"The Protocol used for this Probe. Possible values are Http and Https."', args=[d.arg(name='protocol', type=d.T.string)]),
        withProtocol(protocol): { protocol: protocol },
        '#withTimeout':: d.fn(help='"The Timeout used for this Probe, which indicates when a probe becomes unhealthy. Possible values range from 1 second to a maximum of 86,400 seconds."', args=[d.arg(name='timeout', type=d.T.number)]),
        withTimeout(timeout): { timeout: timeout },
        '#withUnhealthyThreshold':: d.fn(help='"The Unhealthy Threshold for this Probe, which indicates the amount of retries which should be attempted before a node is deemed unhealthy. Possible values are from 1 - 20 seconds."', args=[d.arg(name='unhealthyThreshold', type=d.T.number)]),
        withUnhealthyThreshold(unhealthyThreshold): { unhealthyThreshold: unhealthyThreshold },
      },
      '#redirectConfiguration':: d.obj(help='"One or more redirect_configuration blocks as defined below."'),
      redirectConfiguration: {
        '#withIncludePath':: d.fn(help='"Whether or not to include the path in the redirected Url. Defaults to false"', args=[d.arg(name='includePath', type=d.T.boolean)]),
        withIncludePath(includePath): { includePath: includePath },
        '#withIncludeQueryString':: d.fn(help='"Whether or not to include the query string in the redirected Url. Default to false"', args=[d.arg(name='includeQueryString', type=d.T.boolean)]),
        withIncludeQueryString(includeQueryString): { includeQueryString: includeQueryString },
        '#withName':: d.fn(help='"Unique name of the redirect configuration block"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withRedirectType':: d.fn(help='"The type of redirect. Possible values are Permanent, Temporary, Found and SeeOther"', args=[d.arg(name='redirectType', type=d.T.string)]),
        withRedirectType(redirectType): { redirectType: redirectType },
        '#withTargetListenerName':: d.fn(help='"The name of the listener to redirect to. Cannot be set if target_url is set."', args=[d.arg(name='targetListenerName', type=d.T.string)]),
        withTargetListenerName(targetListenerName): { targetListenerName: targetListenerName },
        '#withTargetUrl':: d.fn(help='"The Url to redirect the request to. Cannot be set if target_listener_name is set."', args=[d.arg(name='targetUrl', type=d.T.string)]),
        withTargetUrl(targetUrl): { targetUrl: targetUrl },
      },
      '#requestRoutingRule':: d.obj(help='"One or more request_routing_rule blocks as defined below."'),
      requestRoutingRule: {
        '#withBackendAddressPoolName':: d.fn(help='"The Name of the Backend Address Pool which should be used for this Routing Rule. Cannot be set if redirect_configuration_name is set."', args=[d.arg(name='backendAddressPoolName', type=d.T.string)]),
        withBackendAddressPoolName(backendAddressPoolName): { backendAddressPoolName: backendAddressPoolName },
        '#withBackendHttpSettingsName':: d.fn(help='"The Name of the Backend HTTP Settings Collection which should be used for this Routing Rule. Cannot be set if redirect_configuration_name is set."', args=[d.arg(name='backendHttpSettingsName', type=d.T.string)]),
        withBackendHttpSettingsName(backendHttpSettingsName): { backendHttpSettingsName: backendHttpSettingsName },
        '#withHttpListenerName':: d.fn(help='"The Name of the HTTP Listener which should be used for this Routing Rule."', args=[d.arg(name='httpListenerName', type=d.T.string)]),
        withHttpListenerName(httpListenerName): { httpListenerName: httpListenerName },
        '#withName':: d.fn(help='"The Name of this Request Routing Rule."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withPriority':: d.fn(help='"Rule evaluation order can be dictated by specifying an integer value from 1 to 20000 with 1 being the highest priority and 20000 being the lowest priority."', args=[d.arg(name='priority', type=d.T.number)]),
        withPriority(priority): { priority: priority },
        '#withRedirectConfigurationName':: d.fn(help='"The Name of the Redirect Configuration which should be used for this Routing Rule. Cannot be set if either backend_address_pool_name or backend_http_settings_name is set."', args=[d.arg(name='redirectConfigurationName', type=d.T.string)]),
        withRedirectConfigurationName(redirectConfigurationName): { redirectConfigurationName: redirectConfigurationName },
        '#withRewriteRuleSetName':: d.fn(help='"The Name of the Rewrite Rule Set which should be used for this Routing Rule. Only valid for v2 SKUs."', args=[d.arg(name='rewriteRuleSetName', type=d.T.string)]),
        withRewriteRuleSetName(rewriteRuleSetName): { rewriteRuleSetName: rewriteRuleSetName },
        '#withRuleType':: d.fn(help='"The Type of Routing that should be used for this Rule. Possible values are Basic and PathBasedRouting."', args=[d.arg(name='ruleType', type=d.T.string)]),
        withRuleType(ruleType): { ruleType: ruleType },
        '#withUrlPathMapName':: d.fn(help='"The Name of the URL Path Map which should be associated with this Routing Rule."', args=[d.arg(name='urlPathMapName', type=d.T.string)]),
        withUrlPathMapName(urlPathMapName): { urlPathMapName: urlPathMapName },
      },
      '#resourceGroupNameRef':: d.obj(help='"Reference to a ResourceGroup in azure to populate resourceGroupName."'),
      resourceGroupNameRef: {
        '#policy':: d.obj(help='"Policies for referencing."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { forProvider+: { resourceGroupNameRef+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { forProvider+: { resourceGroupNameRef+: { policy+: { resolve: resolve } } } } },
        },
        '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { forProvider+: { resourceGroupNameRef+: { name: name } } } },
      },
      '#resourceGroupNameSelector':: d.obj(help='"Selector for a ResourceGroup in azure to populate resourceGroupName."'),
      resourceGroupNameSelector: {
        '#policy':: d.obj(help='"Policies for selection."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { forProvider+: { resourceGroupNameSelector+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { forProvider+: { resourceGroupNameSelector+: { policy+: { resolve: resolve } } } } },
        },
        '#withMatchControllerRef':: d.fn(help='"MatchControllerRef ensures an object with the same controller reference as the selecting object is selected."', args=[d.arg(name='matchControllerRef', type=d.T.boolean)]),
        withMatchControllerRef(matchControllerRef): { spec+: { forProvider+: { resourceGroupNameSelector+: { matchControllerRef: matchControllerRef } } } },
        '#withMatchLabels':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabels(matchLabels): { spec+: { forProvider+: { resourceGroupNameSelector+: { matchLabels: matchLabels } } } },
        '#withMatchLabelsMixin':: d.fn(help='"MatchLabels ensures an object with matching labels is selected."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
        withMatchLabelsMixin(matchLabels): { spec+: { forProvider+: { resourceGroupNameSelector+: { matchLabels+: matchLabels } } } },
      },
      '#rewriteRuleSet':: d.obj(help='"One or more rewrite_rule_set blocks as defined below. Only valid for v2 SKUs."'),
      rewriteRuleSet: {
        '#rewriteRule':: d.obj(help='"One or more rewrite_rule blocks as defined above."'),
        rewriteRule: {
          '#condition':: d.obj(help='"One or more condition blocks as defined above."'),
          condition: {
            '#withIgnoreCase':: d.fn(help='"Perform a case in-sensitive comparison. Defaults to false"', args=[d.arg(name='ignoreCase', type=d.T.boolean)]),
            withIgnoreCase(ignoreCase): { ignoreCase: ignoreCase },
            '#withNegate':: d.fn(help='"Negate the result of the condition evaluation. Defaults to false"', args=[d.arg(name='negate', type=d.T.boolean)]),
            withNegate(negate): { negate: negate },
            '#withPattern':: d.fn(help='"The pattern, either fixed string or regular expression, that evaluates the truthfulness of the condition."', args=[d.arg(name='pattern', type=d.T.string)]),
            withPattern(pattern): { pattern: pattern },
            '#withVariable':: d.fn(help='"The variable of the condition."', args=[d.arg(name='variable', type=d.T.string)]),
            withVariable(variable): { variable: variable },
          },
          '#requestHeaderConfiguration':: d.obj(help='"One or more request_header_configuration blocks as defined above."'),
          requestHeaderConfiguration: {
            '#withHeaderName':: d.fn(help='"Header name of the header configuration."', args=[d.arg(name='headerName', type=d.T.string)]),
            withHeaderName(headerName): { headerName: headerName },
            '#withHeaderValue':: d.fn(help='"Header value of the header configuration. To delete a response header set this property to an empty string."', args=[d.arg(name='headerValue', type=d.T.string)]),
            withHeaderValue(headerValue): { headerValue: headerValue },
          },
          '#responseHeaderConfiguration':: d.obj(help='"One or more response_header_configuration blocks as defined above."'),
          responseHeaderConfiguration: {
            '#withHeaderName':: d.fn(help='"Header name of the header configuration."', args=[d.arg(name='headerName', type=d.T.string)]),
            withHeaderName(headerName): { headerName: headerName },
            '#withHeaderValue':: d.fn(help='"Header value of the header configuration. To delete a response header set this property to an empty string."', args=[d.arg(name='headerValue', type=d.T.string)]),
            withHeaderValue(headerValue): { headerValue: headerValue },
          },
          '#url':: d.obj(help='"One url block as defined above"'),
          url: {
            '#withPath':: d.fn(help='"The URL path to rewrite."', args=[d.arg(name='path', type=d.T.string)]),
            withPath(path): { path: path },
            '#withQueryString':: d.fn(help='"The query string to rewrite."', args=[d.arg(name='queryString', type=d.T.string)]),
            withQueryString(queryString): { queryString: queryString },
            '#withReroute':: d.fn(help='"Whether the URL path map should be reevaluated after this rewrite has been applied. More info on rewrite configutation"', args=[d.arg(name='reroute', type=d.T.boolean)]),
            withReroute(reroute): { reroute: reroute },
          },
          '#withCondition':: d.fn(help='"One or more condition blocks as defined above."', args=[d.arg(name='condition', type=d.T.array)]),
          withCondition(condition): { condition: if std.isArray(v=condition) then condition else [condition] },
          '#withConditionMixin':: d.fn(help='"One or more condition blocks as defined above."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='condition', type=d.T.array)]),
          withConditionMixin(condition): { condition+: if std.isArray(v=condition) then condition else [condition] },
          '#withName':: d.fn(help='"The Name of the URL Path Map."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withRequestHeaderConfiguration':: d.fn(help='"One or more request_header_configuration blocks as defined above."', args=[d.arg(name='requestHeaderConfiguration', type=d.T.array)]),
          withRequestHeaderConfiguration(requestHeaderConfiguration): { requestHeaderConfiguration: if std.isArray(v=requestHeaderConfiguration) then requestHeaderConfiguration else [requestHeaderConfiguration] },
          '#withRequestHeaderConfigurationMixin':: d.fn(help='"One or more request_header_configuration blocks as defined above."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requestHeaderConfiguration', type=d.T.array)]),
          withRequestHeaderConfigurationMixin(requestHeaderConfiguration): { requestHeaderConfiguration+: if std.isArray(v=requestHeaderConfiguration) then requestHeaderConfiguration else [requestHeaderConfiguration] },
          '#withResponseHeaderConfiguration':: d.fn(help='"One or more response_header_configuration blocks as defined above."', args=[d.arg(name='responseHeaderConfiguration', type=d.T.array)]),
          withResponseHeaderConfiguration(responseHeaderConfiguration): { responseHeaderConfiguration: if std.isArray(v=responseHeaderConfiguration) then responseHeaderConfiguration else [responseHeaderConfiguration] },
          '#withResponseHeaderConfigurationMixin':: d.fn(help='"One or more response_header_configuration blocks as defined above."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='responseHeaderConfiguration', type=d.T.array)]),
          withResponseHeaderConfigurationMixin(responseHeaderConfiguration): { responseHeaderConfiguration+: if std.isArray(v=responseHeaderConfiguration) then responseHeaderConfiguration else [responseHeaderConfiguration] },
          '#withRuleSequence':: d.fn(help='"Rule sequence of the rewrite rule that determines the order of execution in a set."', args=[d.arg(name='ruleSequence', type=d.T.number)]),
          withRuleSequence(ruleSequence): { ruleSequence: ruleSequence },
          '#withUrl':: d.fn(help='"One url block as defined above"', args=[d.arg(name='url', type=d.T.array)]),
          withUrl(url): { url: if std.isArray(v=url) then url else [url] },
          '#withUrlMixin':: d.fn(help='"One url block as defined above"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='url', type=d.T.array)]),
          withUrlMixin(url): { url+: if std.isArray(v=url) then url else [url] },
        },
        '#withName':: d.fn(help='"Unique name of the rewrite rule set block"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withRewriteRule':: d.fn(help='"One or more rewrite_rule blocks as defined above."', args=[d.arg(name='rewriteRule', type=d.T.array)]),
        withRewriteRule(rewriteRule): { rewriteRule: if std.isArray(v=rewriteRule) then rewriteRule else [rewriteRule] },
        '#withRewriteRuleMixin':: d.fn(help='"One or more rewrite_rule blocks as defined above."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rewriteRule', type=d.T.array)]),
        withRewriteRuleMixin(rewriteRule): { rewriteRule+: if std.isArray(v=rewriteRule) then rewriteRule else [rewriteRule] },
      },
      '#sku':: d.obj(help='"A sku block as defined below."'),
      sku: {
        '#withCapacity':: d.fn(help='"The Capacity of the SKU to use for this Application Gateway. When using a V1 SKU this value must be between 1 and 32, and 1 to 125 for a V2 SKU. This property is optional if autoscale_configuration is set."', args=[d.arg(name='capacity', type=d.T.number)]),
        withCapacity(capacity): { capacity: capacity },
        '#withName':: d.fn(help='"The Name of the SKU to use for this Application Gateway. Possible values are Standard_Small, Standard_Medium, Standard_Large, Standard_v2, WAF_Medium, WAF_Large, and WAF_v2."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withTier':: d.fn(help='"The Tier of the SKU to use for this Application Gateway. Possible values are Standard, Standard_v2, WAF and WAF_v2."', args=[d.arg(name='tier', type=d.T.string)]),
        withTier(tier): { tier: tier },
      },
      '#sslCertificate':: d.obj(help='"One or more ssl_certificate blocks as defined below."'),
      sslCertificate: {
        '#dataSecretRef':: d.obj(help='"PFX certificate. Required if key_vault_secret_id is not set."'),
        dataSecretRef: {
          '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { dataSecretRef+: { key: key } },
          '#withName':: d.fn(help='"Name of the secret."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { dataSecretRef+: { name: name } },
          '#withNamespace':: d.fn(help='"Namespace of the secret."', args=[d.arg(name='namespace', type=d.T.string)]),
          withNamespace(namespace): { dataSecretRef+: { namespace: namespace } },
        },
        '#passwordSecretRef':: d.obj(help='"Password for the pfx file specified in data.  Required if data is set."'),
        passwordSecretRef: {
          '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { passwordSecretRef+: { key: key } },
          '#withName':: d.fn(help='"Name of the secret."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { passwordSecretRef+: { name: name } },
          '#withNamespace':: d.fn(help='"Namespace of the secret."', args=[d.arg(name='namespace', type=d.T.string)]),
          withNamespace(namespace): { passwordSecretRef+: { namespace: namespace } },
        },
        '#withKeyVaultSecretId':: d.fn(help='"Secret Id of (base-64 encoded unencrypted pfx) Secret or Certificate object stored in Azure KeyVault. You need to enable soft delete for keyvault to use this feature. Required if data is not set."', args=[d.arg(name='keyVaultSecretId', type=d.T.string)]),
        withKeyVaultSecretId(keyVaultSecretId): { keyVaultSecretId: keyVaultSecretId },
        '#withName':: d.fn(help='"The Name of the SSL certificate that is unique within this Application Gateway"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#sslPolicy':: d.obj(help='"a ssl policy block as defined below."'),
      sslPolicy: {
        '#withCipherSuites':: d.fn(help='"A List of accepted cipher suites. Possible values are: TLS_DHE_DSS_WITH_AES_128_CBC_SHA, TLS_DHE_DSS_WITH_AES_128_CBC_SHA256, TLS_DHE_DSS_WITH_AES_256_CBC_SHA, TLS_DHE_DSS_WITH_AES_256_CBC_SHA256, TLS_DHE_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_GCM_SHA256, TLS_DHE_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384, TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA256 and TLS_RSA_WITH_AES_256_GCM_SHA384."', args=[d.arg(name='cipherSuites', type=d.T.array)]),
        withCipherSuites(cipherSuites): { cipherSuites: if std.isArray(v=cipherSuites) then cipherSuites else [cipherSuites] },
        '#withCipherSuitesMixin':: d.fn(help='"A List of accepted cipher suites. Possible values are: TLS_DHE_DSS_WITH_AES_128_CBC_SHA, TLS_DHE_DSS_WITH_AES_128_CBC_SHA256, TLS_DHE_DSS_WITH_AES_256_CBC_SHA, TLS_DHE_DSS_WITH_AES_256_CBC_SHA256, TLS_DHE_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_GCM_SHA256, TLS_DHE_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384, TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA256 and TLS_RSA_WITH_AES_256_GCM_SHA384."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='cipherSuites', type=d.T.array)]),
        withCipherSuitesMixin(cipherSuites): { cipherSuites+: if std.isArray(v=cipherSuites) then cipherSuites else [cipherSuites] },
        '#withDisabledProtocols':: d.fn(help='"A list of SSL Protocols which should be disabled on this Application Gateway. Possible values are TLSv1_0, TLSv1_1 and TLSv1_2."', args=[d.arg(name='disabledProtocols', type=d.T.array)]),
        withDisabledProtocols(disabledProtocols): { disabledProtocols: if std.isArray(v=disabledProtocols) then disabledProtocols else [disabledProtocols] },
        '#withDisabledProtocolsMixin':: d.fn(help='"A list of SSL Protocols which should be disabled on this Application Gateway. Possible values are TLSv1_0, TLSv1_1 and TLSv1_2."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='disabledProtocols', type=d.T.array)]),
        withDisabledProtocolsMixin(disabledProtocols): { disabledProtocols+: if std.isArray(v=disabledProtocols) then disabledProtocols else [disabledProtocols] },
        '#withMinProtocolVersion':: d.fn(help='"The minimal TLS version. Possible values are TLSv1_0, TLSv1_1 and TLSv1_2."', args=[d.arg(name='minProtocolVersion', type=d.T.string)]),
        withMinProtocolVersion(minProtocolVersion): { minProtocolVersion: minProtocolVersion },
        '#withPolicyName':: d.fn(help='"The Name of the Policy e.g AppGwSslPolicy20170401S. Required if policy_type is set to Predefined. Possible values can change over time and are published here https://docs.microsoft.com/azure/application-gateway/application-gateway-ssl-policy-overview. Not compatible with disabled_protocols."', args=[d.arg(name='policyName', type=d.T.string)]),
        withPolicyName(policyName): { policyName: policyName },
        '#withPolicyType':: d.fn(help='"The Type of the Policy. Possible values are Predefined and Custom."', args=[d.arg(name='policyType', type=d.T.string)]),
        withPolicyType(policyType): { policyType: policyType },
      },
      '#sslProfile':: d.obj(help='"One or more ssl_profile blocks as defined below."'),
      sslProfile: {
        '#sslPolicy':: d.obj(help='"a ssl policy block as defined below."'),
        sslPolicy: {
          '#withCipherSuites':: d.fn(help='"A List of accepted cipher suites. Possible values are: TLS_DHE_DSS_WITH_AES_128_CBC_SHA, TLS_DHE_DSS_WITH_AES_128_CBC_SHA256, TLS_DHE_DSS_WITH_AES_256_CBC_SHA, TLS_DHE_DSS_WITH_AES_256_CBC_SHA256, TLS_DHE_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_GCM_SHA256, TLS_DHE_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384, TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA256 and TLS_RSA_WITH_AES_256_GCM_SHA384."', args=[d.arg(name='cipherSuites', type=d.T.array)]),
          withCipherSuites(cipherSuites): { cipherSuites: if std.isArray(v=cipherSuites) then cipherSuites else [cipherSuites] },
          '#withCipherSuitesMixin':: d.fn(help='"A List of accepted cipher suites. Possible values are: TLS_DHE_DSS_WITH_AES_128_CBC_SHA, TLS_DHE_DSS_WITH_AES_128_CBC_SHA256, TLS_DHE_DSS_WITH_AES_256_CBC_SHA, TLS_DHE_DSS_WITH_AES_256_CBC_SHA256, TLS_DHE_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_GCM_SHA256, TLS_DHE_RSA_WITH_AES_256_CBC_SHA, TLS_DHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384, TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA256 and TLS_RSA_WITH_AES_256_GCM_SHA384."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='cipherSuites', type=d.T.array)]),
          withCipherSuitesMixin(cipherSuites): { cipherSuites+: if std.isArray(v=cipherSuites) then cipherSuites else [cipherSuites] },
          '#withDisabledProtocols':: d.fn(help='"A list of SSL Protocols which should be disabled on this Application Gateway. Possible values are TLSv1_0, TLSv1_1 and TLSv1_2."', args=[d.arg(name='disabledProtocols', type=d.T.array)]),
          withDisabledProtocols(disabledProtocols): { disabledProtocols: if std.isArray(v=disabledProtocols) then disabledProtocols else [disabledProtocols] },
          '#withDisabledProtocolsMixin':: d.fn(help='"A list of SSL Protocols which should be disabled on this Application Gateway. Possible values are TLSv1_0, TLSv1_1 and TLSv1_2."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='disabledProtocols', type=d.T.array)]),
          withDisabledProtocolsMixin(disabledProtocols): { disabledProtocols+: if std.isArray(v=disabledProtocols) then disabledProtocols else [disabledProtocols] },
          '#withMinProtocolVersion':: d.fn(help='"The minimal TLS version. Possible values are TLSv1_0, TLSv1_1 and TLSv1_2."', args=[d.arg(name='minProtocolVersion', type=d.T.string)]),
          withMinProtocolVersion(minProtocolVersion): { minProtocolVersion: minProtocolVersion },
          '#withPolicyName':: d.fn(help='"The Name of the Policy e.g AppGwSslPolicy20170401S. Required if policy_type is set to Predefined. Possible values can change over time and are published here https://docs.microsoft.com/azure/application-gateway/application-gateway-ssl-policy-overview. Not compatible with disabled_protocols."', args=[d.arg(name='policyName', type=d.T.string)]),
          withPolicyName(policyName): { policyName: policyName },
          '#withPolicyType':: d.fn(help='"The Type of the Policy. Possible values are Predefined and Custom."', args=[d.arg(name='policyType', type=d.T.string)]),
          withPolicyType(policyType): { policyType: policyType },
        },
        '#withName':: d.fn(help='"The name of the SSL Profile that is unique within this Application Gateway."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withSslPolicy':: d.fn(help='"a ssl policy block as defined below."', args=[d.arg(name='sslPolicy', type=d.T.array)]),
        withSslPolicy(sslPolicy): { sslPolicy: if std.isArray(v=sslPolicy) then sslPolicy else [sslPolicy] },
        '#withSslPolicyMixin':: d.fn(help='"a ssl policy block as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sslPolicy', type=d.T.array)]),
        withSslPolicyMixin(sslPolicy): { sslPolicy+: if std.isArray(v=sslPolicy) then sslPolicy else [sslPolicy] },
        '#withTrustedClientCertificateNames':: d.fn(help='"The name of the Trusted Client Certificate that will be used to authenticate requests from clients."', args=[d.arg(name='trustedClientCertificateNames', type=d.T.array)]),
        withTrustedClientCertificateNames(trustedClientCertificateNames): { trustedClientCertificateNames: if std.isArray(v=trustedClientCertificateNames) then trustedClientCertificateNames else [trustedClientCertificateNames] },
        '#withTrustedClientCertificateNamesMixin':: d.fn(help='"The name of the Trusted Client Certificate that will be used to authenticate requests from clients."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='trustedClientCertificateNames', type=d.T.array)]),
        withTrustedClientCertificateNamesMixin(trustedClientCertificateNames): { trustedClientCertificateNames+: if std.isArray(v=trustedClientCertificateNames) then trustedClientCertificateNames else [trustedClientCertificateNames] },
        '#withVerifyClientCertIssuerDn':: d.fn(help='"Should client certificate issuer DN be verified?  Defaults to false."', args=[d.arg(name='verifyClientCertIssuerDn', type=d.T.boolean)]),
        withVerifyClientCertIssuerDn(verifyClientCertIssuerDn): { verifyClientCertIssuerDn: verifyClientCertIssuerDn },
      },
      '#trustedClientCertificate':: d.obj(help='"One or more trusted_client_certificate blocks as defined below."'),
      trustedClientCertificate: {
        '#dataSecretRef':: d.obj(help='"The base-64 encoded certificate."'),
        dataSecretRef: {
          '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { dataSecretRef+: { key: key } },
          '#withName':: d.fn(help='"Name of the secret."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { dataSecretRef+: { name: name } },
          '#withNamespace':: d.fn(help='"Namespace of the secret."', args=[d.arg(name='namespace', type=d.T.string)]),
          withNamespace(namespace): { dataSecretRef+: { namespace: namespace } },
        },
        '#withName':: d.fn(help='"The name of the Trusted Client Certificate that is unique within this Application Gateway."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#trustedRootCertificate':: d.obj(help='"One or more trusted_root_certificate blocks as defined below."'),
      trustedRootCertificate: {
        '#dataSecretRef':: d.obj(help='"The contents of the Trusted Root Certificate which should be used. Required if key_vault_secret_id is not set."'),
        dataSecretRef: {
          '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { dataSecretRef+: { key: key } },
          '#withName':: d.fn(help='"Name of the secret."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { dataSecretRef+: { name: name } },
          '#withNamespace':: d.fn(help='"Namespace of the secret."', args=[d.arg(name='namespace', type=d.T.string)]),
          withNamespace(namespace): { dataSecretRef+: { namespace: namespace } },
        },
        '#withKeyVaultSecretId':: d.fn(help='"The Secret ID of (base-64 encoded unencrypted pfx) Secret or Certificate object stored in Azure KeyVault. You need to enable soft delete for the Key Vault to use this feature. Required if data is not set."', args=[d.arg(name='keyVaultSecretId', type=d.T.string)]),
        withKeyVaultSecretId(keyVaultSecretId): { keyVaultSecretId: keyVaultSecretId },
        '#withName':: d.fn(help='"The Name of the Trusted Root Certificate to use."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#urlPathMap':: d.obj(help='"One or more url_path_map blocks as defined below."'),
      urlPathMap: {
        '#pathRule':: d.obj(help='"One or more path_rule blocks as defined above."'),
        pathRule: {
          '#withBackendAddressPoolName':: d.fn(help='"The Name of the Backend Address Pool which should be used for this Routing Rule. Cannot be set if redirect_configuration_name is set."', args=[d.arg(name='backendAddressPoolName', type=d.T.string)]),
          withBackendAddressPoolName(backendAddressPoolName): { backendAddressPoolName: backendAddressPoolName },
          '#withBackendHttpSettingsName':: d.fn(help='"The Name of the Backend HTTP Settings Collection which should be used for this Routing Rule. Cannot be set if redirect_configuration_name is set."', args=[d.arg(name='backendHttpSettingsName', type=d.T.string)]),
          withBackendHttpSettingsName(backendHttpSettingsName): { backendHttpSettingsName: backendHttpSettingsName },
          '#withFirewallPolicyId':: d.fn(help='"The ID of the Web Application Firewall Policy which should be used as a HTTP Listener."', args=[d.arg(name='firewallPolicyId', type=d.T.string)]),
          withFirewallPolicyId(firewallPolicyId): { firewallPolicyId: firewallPolicyId },
          '#withName':: d.fn(help='"The Name of the URL Path Map."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withPaths':: d.fn(help='"A list of Paths used in this Path Rule."', args=[d.arg(name='paths', type=d.T.array)]),
          withPaths(paths): { paths: if std.isArray(v=paths) then paths else [paths] },
          '#withPathsMixin':: d.fn(help='"A list of Paths used in this Path Rule."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='paths', type=d.T.array)]),
          withPathsMixin(paths): { paths+: if std.isArray(v=paths) then paths else [paths] },
          '#withRedirectConfigurationName':: d.fn(help='"The Name of the Redirect Configuration which should be used for this Routing Rule. Cannot be set if either backend_address_pool_name or backend_http_settings_name is set."', args=[d.arg(name='redirectConfigurationName', type=d.T.string)]),
          withRedirectConfigurationName(redirectConfigurationName): { redirectConfigurationName: redirectConfigurationName },
          '#withRewriteRuleSetName':: d.fn(help='"The Name of the Rewrite Rule Set which should be used for this Routing Rule. Only valid for v2 SKUs."', args=[d.arg(name='rewriteRuleSetName', type=d.T.string)]),
          withRewriteRuleSetName(rewriteRuleSetName): { rewriteRuleSetName: rewriteRuleSetName },
        },
        '#withDefaultBackendAddressPoolName':: d.fn(help='"The Name of the Default Backend Address Pool which should be used for this URL Path Map. Cannot be set if default_redirect_configuration_name is set."', args=[d.arg(name='defaultBackendAddressPoolName', type=d.T.string)]),
        withDefaultBackendAddressPoolName(defaultBackendAddressPoolName): { defaultBackendAddressPoolName: defaultBackendAddressPoolName },
        '#withDefaultBackendHttpSettingsName':: d.fn(help='"The Name of the Default Backend HTTP Settings Collection which should be used for this URL Path Map. Cannot be set if default_redirect_configuration_name is set."', args=[d.arg(name='defaultBackendHttpSettingsName', type=d.T.string)]),
        withDefaultBackendHttpSettingsName(defaultBackendHttpSettingsName): { defaultBackendHttpSettingsName: defaultBackendHttpSettingsName },
        '#withDefaultRedirectConfigurationName':: d.fn(help='"The Name of the Default Redirect Configuration which should be used for this URL Path Map. Cannot be set if either default_backend_address_pool_name or default_backend_http_settings_name is set."', args=[d.arg(name='defaultRedirectConfigurationName', type=d.T.string)]),
        withDefaultRedirectConfigurationName(defaultRedirectConfigurationName): { defaultRedirectConfigurationName: defaultRedirectConfigurationName },
        '#withDefaultRewriteRuleSetName':: d.fn(help='"The Name of the Default Rewrite Rule Set which should be used for this URL Path Map. Only valid for v2 SKUs."', args=[d.arg(name='defaultRewriteRuleSetName', type=d.T.string)]),
        withDefaultRewriteRuleSetName(defaultRewriteRuleSetName): { defaultRewriteRuleSetName: defaultRewriteRuleSetName },
        '#withName':: d.fn(help='"The Name of the URL Path Map."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withPathRule':: d.fn(help='"One or more path_rule blocks as defined above."', args=[d.arg(name='pathRule', type=d.T.array)]),
        withPathRule(pathRule): { pathRule: if std.isArray(v=pathRule) then pathRule else [pathRule] },
        '#withPathRuleMixin':: d.fn(help='"One or more path_rule blocks as defined above."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='pathRule', type=d.T.array)]),
        withPathRuleMixin(pathRule): { pathRule+: if std.isArray(v=pathRule) then pathRule else [pathRule] },
      },
      '#wafConfiguration':: d.obj(help='"A waf_configuration block as defined below."'),
      wafConfiguration: {
        '#disabledRuleGroup':: d.obj(help='"one or more disabled_rule_group blocks as defined below."'),
        disabledRuleGroup: {
          '#withRuleGroupName':: d.fn(help='"The rule group where specific rules should be disabled. Accepted values are:  crs_20_protocol_violations, crs_21_protocol_anomalies, crs_23_request_limits, crs_30_http_policy, crs_35_bad_robots, crs_40_generic_attacks, crs_41_sql_injection_attacks, crs_41_xss_attacks, crs_42_tight_security, crs_45_trojans, General, REQUEST-911-METHOD-ENFORCEMENT, REQUEST-913-SCANNER-DETECTION, REQUEST-920-PROTOCOL-ENFORCEMENT, REQUEST-921-PROTOCOL-ATTACK, REQUEST-930-APPLICATION-ATTACK-LFI, REQUEST-931-APPLICATION-ATTACK-RFI, REQUEST-932-APPLICATION-ATTACK-RCE, REQUEST-933-APPLICATION-ATTACK-PHP, REQUEST-941-APPLICATION-ATTACK-XSS, REQUEST-942-APPLICATION-ATTACK-SQLI, REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION"', args=[d.arg(name='ruleGroupName', type=d.T.string)]),
          withRuleGroupName(ruleGroupName): { ruleGroupName: ruleGroupName },
          '#withRules':: d.fn(help='"A list of rules which should be disabled in that group. Disables all rules in the specified group if rules is not specified."', args=[d.arg(name='rules', type=d.T.array)]),
          withRules(rules): { rules: if std.isArray(v=rules) then rules else [rules] },
          '#withRulesMixin':: d.fn(help='"A list of rules which should be disabled in that group. Disables all rules in the specified group if rules is not specified."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rules', type=d.T.array)]),
          withRulesMixin(rules): { rules+: if std.isArray(v=rules) then rules else [rules] },
        },
        '#exclusion':: d.obj(help='"one or more exclusion blocks as defined below."'),
        exclusion: {
          '#withMatchVariable':: d.fn(help='"Match variable of the exclusion rule to exclude header, cookie or GET arguments. Possible values are RequestHeaderNames, RequestArgNames and RequestCookieNames"', args=[d.arg(name='matchVariable', type=d.T.string)]),
          withMatchVariable(matchVariable): { matchVariable: matchVariable },
          '#withSelector':: d.fn(help='"String value which will be used for the filter operation. If empty will exclude all traffic on this match_variable"', args=[d.arg(name='selector', type=d.T.string)]),
          withSelector(selector): { selector: selector },
          '#withSelectorMatchOperator':: d.fn(help='"Operator which will be used to search in the variable content. Possible values are Equals, StartsWith, EndsWith, Contains. If empty will exclude all traffic on this match_variable"', args=[d.arg(name='selectorMatchOperator', type=d.T.string)]),
          withSelectorMatchOperator(selectorMatchOperator): { selectorMatchOperator: selectorMatchOperator },
        },
        '#withDisabledRuleGroup':: d.fn(help='"one or more disabled_rule_group blocks as defined below."', args=[d.arg(name='disabledRuleGroup', type=d.T.array)]),
        withDisabledRuleGroup(disabledRuleGroup): { disabledRuleGroup: if std.isArray(v=disabledRuleGroup) then disabledRuleGroup else [disabledRuleGroup] },
        '#withDisabledRuleGroupMixin':: d.fn(help='"one or more disabled_rule_group blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='disabledRuleGroup', type=d.T.array)]),
        withDisabledRuleGroupMixin(disabledRuleGroup): { disabledRuleGroup+: if std.isArray(v=disabledRuleGroup) then disabledRuleGroup else [disabledRuleGroup] },
        '#withEnabled':: d.fn(help='"Is the Web Application Firewall be enabled?"', args=[d.arg(name='enabled', type=d.T.boolean)]),
        withEnabled(enabled): { enabled: enabled },
        '#withExclusion':: d.fn(help='"one or more exclusion blocks as defined below."', args=[d.arg(name='exclusion', type=d.T.array)]),
        withExclusion(exclusion): { exclusion: if std.isArray(v=exclusion) then exclusion else [exclusion] },
        '#withExclusionMixin':: d.fn(help='"one or more exclusion blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='exclusion', type=d.T.array)]),
        withExclusionMixin(exclusion): { exclusion+: if std.isArray(v=exclusion) then exclusion else [exclusion] },
        '#withFileUploadLimitMb':: d.fn(help='"The File Upload Limit in MB. Accepted values are in the range 1MB to 750MB for the WAF_v2 SKU, and 1MB to 500MB for all other SKUs. Defaults to 100MB."', args=[d.arg(name='fileUploadLimitMb', type=d.T.number)]),
        withFileUploadLimitMb(fileUploadLimitMb): { fileUploadLimitMb: fileUploadLimitMb },
        '#withFirewallMode':: d.fn(help='"The Web Application Firewall Mode. Possible values are Detection and Prevention."', args=[d.arg(name='firewallMode', type=d.T.string)]),
        withFirewallMode(firewallMode): { firewallMode: firewallMode },
        '#withMaxRequestBodySizeKb':: d.fn(help='"The Maximum Request Body Size in KB.  Accepted values are in the range 1KB to 128KB.  Defaults to 128KB."', args=[d.arg(name='maxRequestBodySizeKb', type=d.T.number)]),
        withMaxRequestBodySizeKb(maxRequestBodySizeKb): { maxRequestBodySizeKb: maxRequestBodySizeKb },
        '#withRequestBodyCheck':: d.fn(help='"Is Request Body Inspection enabled?  Defaults to true."', args=[d.arg(name='requestBodyCheck', type=d.T.boolean)]),
        withRequestBodyCheck(requestBodyCheck): { requestBodyCheck: requestBodyCheck },
        '#withRuleSetType':: d.fn(help='"The Type of the Rule Set used for this Web Application Firewall. Currently, only OWASP is supported."', args=[d.arg(name='ruleSetType', type=d.T.string)]),
        withRuleSetType(ruleSetType): { ruleSetType: ruleSetType },
        '#withRuleSetVersion':: d.fn(help='"The Version of the Rule Set used for this Web Application Firewall. Possible values are 2.2.9, 3.0, 3.1,  and 3.2."', args=[d.arg(name='ruleSetVersion', type=d.T.string)]),
        withRuleSetVersion(ruleSetVersion): { ruleSetVersion: ruleSetVersion },
      },
      '#withAuthenticationCertificate':: d.fn(help='"One or more authentication_certificate blocks as defined below."', args=[d.arg(name='authenticationCertificate', type=d.T.array)]),
      withAuthenticationCertificate(authenticationCertificate): { spec+: { forProvider+: { authenticationCertificate: if std.isArray(v=authenticationCertificate) then authenticationCertificate else [authenticationCertificate] } } },
      '#withAuthenticationCertificateMixin':: d.fn(help='"One or more authentication_certificate blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='authenticationCertificate', type=d.T.array)]),
      withAuthenticationCertificateMixin(authenticationCertificate): { spec+: { forProvider+: { authenticationCertificate+: if std.isArray(v=authenticationCertificate) then authenticationCertificate else [authenticationCertificate] } } },
      '#withAutoscaleConfiguration':: d.fn(help='"A autoscale_configuration block as defined below."', args=[d.arg(name='autoscaleConfiguration', type=d.T.array)]),
      withAutoscaleConfiguration(autoscaleConfiguration): { spec+: { forProvider+: { autoscaleConfiguration: if std.isArray(v=autoscaleConfiguration) then autoscaleConfiguration else [autoscaleConfiguration] } } },
      '#withAutoscaleConfigurationMixin':: d.fn(help='"A autoscale_configuration block as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='autoscaleConfiguration', type=d.T.array)]),
      withAutoscaleConfigurationMixin(autoscaleConfiguration): { spec+: { forProvider+: { autoscaleConfiguration+: if std.isArray(v=autoscaleConfiguration) then autoscaleConfiguration else [autoscaleConfiguration] } } },
      '#withBackendAddressPool':: d.fn(help='"One or more backend_address_pool blocks as defined below."', args=[d.arg(name='backendAddressPool', type=d.T.array)]),
      withBackendAddressPool(backendAddressPool): { spec+: { forProvider+: { backendAddressPool: if std.isArray(v=backendAddressPool) then backendAddressPool else [backendAddressPool] } } },
      '#withBackendAddressPoolMixin':: d.fn(help='"One or more backend_address_pool blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='backendAddressPool', type=d.T.array)]),
      withBackendAddressPoolMixin(backendAddressPool): { spec+: { forProvider+: { backendAddressPool+: if std.isArray(v=backendAddressPool) then backendAddressPool else [backendAddressPool] } } },
      '#withBackendHttpSettings':: d.fn(help='"One or more backend_http_settings blocks as defined below."', args=[d.arg(name='backendHttpSettings', type=d.T.array)]),
      withBackendHttpSettings(backendHttpSettings): { spec+: { forProvider+: { backendHttpSettings: if std.isArray(v=backendHttpSettings) then backendHttpSettings else [backendHttpSettings] } } },
      '#withBackendHttpSettingsMixin':: d.fn(help='"One or more backend_http_settings blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='backendHttpSettings', type=d.T.array)]),
      withBackendHttpSettingsMixin(backendHttpSettings): { spec+: { forProvider+: { backendHttpSettings+: if std.isArray(v=backendHttpSettings) then backendHttpSettings else [backendHttpSettings] } } },
      '#withCustomErrorConfiguration':: d.fn(help='"One or more custom_error_configuration blocks as defined below."', args=[d.arg(name='customErrorConfiguration', type=d.T.array)]),
      withCustomErrorConfiguration(customErrorConfiguration): { spec+: { forProvider+: { customErrorConfiguration: if std.isArray(v=customErrorConfiguration) then customErrorConfiguration else [customErrorConfiguration] } } },
      '#withCustomErrorConfigurationMixin':: d.fn(help='"One or more custom_error_configuration blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='customErrorConfiguration', type=d.T.array)]),
      withCustomErrorConfigurationMixin(customErrorConfiguration): { spec+: { forProvider+: { customErrorConfiguration+: if std.isArray(v=customErrorConfiguration) then customErrorConfiguration else [customErrorConfiguration] } } },
      '#withEnableHttp2':: d.fn(help='"Is HTTP2 enabled on the application gateway resource? Defaults to false."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
      withEnableHttp2(enableHttp2): { spec+: { forProvider+: { enableHttp2: enableHttp2 } } },
      '#withFipsEnabled':: d.fn(help='"Is FIPS enabled on the Application Gateway?"', args=[d.arg(name='fipsEnabled', type=d.T.boolean)]),
      withFipsEnabled(fipsEnabled): { spec+: { forProvider+: { fipsEnabled: fipsEnabled } } },
      '#withFirewallPolicyId':: d.fn(help='"The ID of the Web Application Firewall Policy."', args=[d.arg(name='firewallPolicyId', type=d.T.string)]),
      withFirewallPolicyId(firewallPolicyId): { spec+: { forProvider+: { firewallPolicyId: firewallPolicyId } } },
      '#withForceFirewallPolicyAssociation':: d.fn(help='"Is the Firewall Policy associated with the Application Gateway?"', args=[d.arg(name='forceFirewallPolicyAssociation', type=d.T.boolean)]),
      withForceFirewallPolicyAssociation(forceFirewallPolicyAssociation): { spec+: { forProvider+: { forceFirewallPolicyAssociation: forceFirewallPolicyAssociation } } },
      '#withFrontendIpConfiguration':: d.fn(help='"One or more frontend_ip_configuration blocks as defined below."', args=[d.arg(name='frontendIpConfiguration', type=d.T.array)]),
      withFrontendIpConfiguration(frontendIpConfiguration): { spec+: { forProvider+: { frontendIpConfiguration: if std.isArray(v=frontendIpConfiguration) then frontendIpConfiguration else [frontendIpConfiguration] } } },
      '#withFrontendIpConfigurationMixin':: d.fn(help='"One or more frontend_ip_configuration blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='frontendIpConfiguration', type=d.T.array)]),
      withFrontendIpConfigurationMixin(frontendIpConfiguration): { spec+: { forProvider+: { frontendIpConfiguration+: if std.isArray(v=frontendIpConfiguration) then frontendIpConfiguration else [frontendIpConfiguration] } } },
      '#withFrontendPort':: d.fn(help='"One or more frontend_port blocks as defined below."', args=[d.arg(name='frontendPort', type=d.T.array)]),
      withFrontendPort(frontendPort): { spec+: { forProvider+: { frontendPort: if std.isArray(v=frontendPort) then frontendPort else [frontendPort] } } },
      '#withFrontendPortMixin':: d.fn(help='"One or more frontend_port blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='frontendPort', type=d.T.array)]),
      withFrontendPortMixin(frontendPort): { spec+: { forProvider+: { frontendPort+: if std.isArray(v=frontendPort) then frontendPort else [frontendPort] } } },
      '#withGatewayIpConfiguration':: d.fn(help='"One or more gateway_ip_configuration blocks as defined below."', args=[d.arg(name='gatewayIpConfiguration', type=d.T.array)]),
      withGatewayIpConfiguration(gatewayIpConfiguration): { spec+: { forProvider+: { gatewayIpConfiguration: if std.isArray(v=gatewayIpConfiguration) then gatewayIpConfiguration else [gatewayIpConfiguration] } } },
      '#withGatewayIpConfigurationMixin':: d.fn(help='"One or more gateway_ip_configuration blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='gatewayIpConfiguration', type=d.T.array)]),
      withGatewayIpConfigurationMixin(gatewayIpConfiguration): { spec+: { forProvider+: { gatewayIpConfiguration+: if std.isArray(v=gatewayIpConfiguration) then gatewayIpConfiguration else [gatewayIpConfiguration] } } },
      '#withHttpListener':: d.fn(help='"One or more http_listener blocks as defined below."', args=[d.arg(name='httpListener', type=d.T.array)]),
      withHttpListener(httpListener): { spec+: { forProvider+: { httpListener: if std.isArray(v=httpListener) then httpListener else [httpListener] } } },
      '#withHttpListenerMixin':: d.fn(help='"One or more http_listener blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='httpListener', type=d.T.array)]),
      withHttpListenerMixin(httpListener): { spec+: { forProvider+: { httpListener+: if std.isArray(v=httpListener) then httpListener else [httpListener] } } },
      '#withIdentity':: d.fn(help='"An identity block as defined below."', args=[d.arg(name='identity', type=d.T.array)]),
      withIdentity(identity): { spec+: { forProvider+: { identity: if std.isArray(v=identity) then identity else [identity] } } },
      '#withIdentityMixin':: d.fn(help='"An identity block as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='identity', type=d.T.array)]),
      withIdentityMixin(identity): { spec+: { forProvider+: { identity+: if std.isArray(v=identity) then identity else [identity] } } },
      '#withLocation':: d.fn(help='"The Azure region where the Application Gateway should exist. Changing this forces a new resource to be created."', args=[d.arg(name='location', type=d.T.string)]),
      withLocation(location): { spec+: { forProvider+: { location: location } } },
      '#withPrivateLinkConfiguration':: d.fn(help='"One or more private_link_configuration blocks as defined below."', args=[d.arg(name='privateLinkConfiguration', type=d.T.array)]),
      withPrivateLinkConfiguration(privateLinkConfiguration): { spec+: { forProvider+: { privateLinkConfiguration: if std.isArray(v=privateLinkConfiguration) then privateLinkConfiguration else [privateLinkConfiguration] } } },
      '#withPrivateLinkConfigurationMixin':: d.fn(help='"One or more private_link_configuration blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='privateLinkConfiguration', type=d.T.array)]),
      withPrivateLinkConfigurationMixin(privateLinkConfiguration): { spec+: { forProvider+: { privateLinkConfiguration+: if std.isArray(v=privateLinkConfiguration) then privateLinkConfiguration else [privateLinkConfiguration] } } },
      '#withProbe':: d.fn(help='"One or more probe blocks as defined below."', args=[d.arg(name='probe', type=d.T.array)]),
      withProbe(probe): { spec+: { forProvider+: { probe: if std.isArray(v=probe) then probe else [probe] } } },
      '#withProbeMixin':: d.fn(help='"One or more probe blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='probe', type=d.T.array)]),
      withProbeMixin(probe): { spec+: { forProvider+: { probe+: if std.isArray(v=probe) then probe else [probe] } } },
      '#withRedirectConfiguration':: d.fn(help='"One or more redirect_configuration blocks as defined below."', args=[d.arg(name='redirectConfiguration', type=d.T.array)]),
      withRedirectConfiguration(redirectConfiguration): { spec+: { forProvider+: { redirectConfiguration: if std.isArray(v=redirectConfiguration) then redirectConfiguration else [redirectConfiguration] } } },
      '#withRedirectConfigurationMixin':: d.fn(help='"One or more redirect_configuration blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='redirectConfiguration', type=d.T.array)]),
      withRedirectConfigurationMixin(redirectConfiguration): { spec+: { forProvider+: { redirectConfiguration+: if std.isArray(v=redirectConfiguration) then redirectConfiguration else [redirectConfiguration] } } },
      '#withRequestRoutingRule':: d.fn(help='"One or more request_routing_rule blocks as defined below."', args=[d.arg(name='requestRoutingRule', type=d.T.array)]),
      withRequestRoutingRule(requestRoutingRule): { spec+: { forProvider+: { requestRoutingRule: if std.isArray(v=requestRoutingRule) then requestRoutingRule else [requestRoutingRule] } } },
      '#withRequestRoutingRuleMixin':: d.fn(help='"One or more request_routing_rule blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requestRoutingRule', type=d.T.array)]),
      withRequestRoutingRuleMixin(requestRoutingRule): { spec+: { forProvider+: { requestRoutingRule+: if std.isArray(v=requestRoutingRule) then requestRoutingRule else [requestRoutingRule] } } },
      '#withResourceGroupName':: d.fn(help='"The name of the resource group in which to the Application Gateway should exist. Changing this forces a new resource to be created."', args=[d.arg(name='resourceGroupName', type=d.T.string)]),
      withResourceGroupName(resourceGroupName): { spec+: { forProvider+: { resourceGroupName: resourceGroupName } } },
      '#withRewriteRuleSet':: d.fn(help='"One or more rewrite_rule_set blocks as defined below. Only valid for v2 SKUs."', args=[d.arg(name='rewriteRuleSet', type=d.T.array)]),
      withRewriteRuleSet(rewriteRuleSet): { spec+: { forProvider+: { rewriteRuleSet: if std.isArray(v=rewriteRuleSet) then rewriteRuleSet else [rewriteRuleSet] } } },
      '#withRewriteRuleSetMixin':: d.fn(help='"One or more rewrite_rule_set blocks as defined below. Only valid for v2 SKUs."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rewriteRuleSet', type=d.T.array)]),
      withRewriteRuleSetMixin(rewriteRuleSet): { spec+: { forProvider+: { rewriteRuleSet+: if std.isArray(v=rewriteRuleSet) then rewriteRuleSet else [rewriteRuleSet] } } },
      '#withSku':: d.fn(help='"A sku block as defined below."', args=[d.arg(name='sku', type=d.T.array)]),
      withSku(sku): { spec+: { forProvider+: { sku: if std.isArray(v=sku) then sku else [sku] } } },
      '#withSkuMixin':: d.fn(help='"A sku block as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sku', type=d.T.array)]),
      withSkuMixin(sku): { spec+: { forProvider+: { sku+: if std.isArray(v=sku) then sku else [sku] } } },
      '#withSslCertificate':: d.fn(help='"One or more ssl_certificate blocks as defined below."', args=[d.arg(name='sslCertificate', type=d.T.array)]),
      withSslCertificate(sslCertificate): { spec+: { forProvider+: { sslCertificate: if std.isArray(v=sslCertificate) then sslCertificate else [sslCertificate] } } },
      '#withSslCertificateMixin':: d.fn(help='"One or more ssl_certificate blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sslCertificate', type=d.T.array)]),
      withSslCertificateMixin(sslCertificate): { spec+: { forProvider+: { sslCertificate+: if std.isArray(v=sslCertificate) then sslCertificate else [sslCertificate] } } },
      '#withSslPolicy':: d.fn(help='"a ssl policy block as defined below."', args=[d.arg(name='sslPolicy', type=d.T.array)]),
      withSslPolicy(sslPolicy): { spec+: { forProvider+: { sslPolicy: if std.isArray(v=sslPolicy) then sslPolicy else [sslPolicy] } } },
      '#withSslPolicyMixin':: d.fn(help='"a ssl policy block as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sslPolicy', type=d.T.array)]),
      withSslPolicyMixin(sslPolicy): { spec+: { forProvider+: { sslPolicy+: if std.isArray(v=sslPolicy) then sslPolicy else [sslPolicy] } } },
      '#withSslProfile':: d.fn(help='"One or more ssl_profile blocks as defined below."', args=[d.arg(name='sslProfile', type=d.T.array)]),
      withSslProfile(sslProfile): { spec+: { forProvider+: { sslProfile: if std.isArray(v=sslProfile) then sslProfile else [sslProfile] } } },
      '#withSslProfileMixin':: d.fn(help='"One or more ssl_profile blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sslProfile', type=d.T.array)]),
      withSslProfileMixin(sslProfile): { spec+: { forProvider+: { sslProfile+: if std.isArray(v=sslProfile) then sslProfile else [sslProfile] } } },
      '#withTags':: d.fn(help='"A mapping of tags to assign to the resource."', args=[d.arg(name='tags', type=d.T.object)]),
      withTags(tags): { spec+: { forProvider+: { tags: tags } } },
      '#withTagsMixin':: d.fn(help='"A mapping of tags to assign to the resource."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.object)]),
      withTagsMixin(tags): { spec+: { forProvider+: { tags+: tags } } },
      '#withTrustedClientCertificate':: d.fn(help='"One or more trusted_client_certificate blocks as defined below."', args=[d.arg(name='trustedClientCertificate', type=d.T.array)]),
      withTrustedClientCertificate(trustedClientCertificate): { spec+: { forProvider+: { trustedClientCertificate: if std.isArray(v=trustedClientCertificate) then trustedClientCertificate else [trustedClientCertificate] } } },
      '#withTrustedClientCertificateMixin':: d.fn(help='"One or more trusted_client_certificate blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='trustedClientCertificate', type=d.T.array)]),
      withTrustedClientCertificateMixin(trustedClientCertificate): { spec+: { forProvider+: { trustedClientCertificate+: if std.isArray(v=trustedClientCertificate) then trustedClientCertificate else [trustedClientCertificate] } } },
      '#withTrustedRootCertificate':: d.fn(help='"One or more trusted_root_certificate blocks as defined below."', args=[d.arg(name='trustedRootCertificate', type=d.T.array)]),
      withTrustedRootCertificate(trustedRootCertificate): { spec+: { forProvider+: { trustedRootCertificate: if std.isArray(v=trustedRootCertificate) then trustedRootCertificate else [trustedRootCertificate] } } },
      '#withTrustedRootCertificateMixin':: d.fn(help='"One or more trusted_root_certificate blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='trustedRootCertificate', type=d.T.array)]),
      withTrustedRootCertificateMixin(trustedRootCertificate): { spec+: { forProvider+: { trustedRootCertificate+: if std.isArray(v=trustedRootCertificate) then trustedRootCertificate else [trustedRootCertificate] } } },
      '#withUrlPathMap':: d.fn(help='"One or more url_path_map blocks as defined below."', args=[d.arg(name='urlPathMap', type=d.T.array)]),
      withUrlPathMap(urlPathMap): { spec+: { forProvider+: { urlPathMap: if std.isArray(v=urlPathMap) then urlPathMap else [urlPathMap] } } },
      '#withUrlPathMapMixin':: d.fn(help='"One or more url_path_map blocks as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='urlPathMap', type=d.T.array)]),
      withUrlPathMapMixin(urlPathMap): { spec+: { forProvider+: { urlPathMap+: if std.isArray(v=urlPathMap) then urlPathMap else [urlPathMap] } } },
      '#withWafConfiguration':: d.fn(help='"A waf_configuration block as defined below."', args=[d.arg(name='wafConfiguration', type=d.T.array)]),
      withWafConfiguration(wafConfiguration): { spec+: { forProvider+: { wafConfiguration: if std.isArray(v=wafConfiguration) then wafConfiguration else [wafConfiguration] } } },
      '#withWafConfigurationMixin':: d.fn(help='"A waf_configuration block as defined below."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wafConfiguration', type=d.T.array)]),
      withWafConfigurationMixin(wafConfiguration): { spec+: { forProvider+: { wafConfiguration+: if std.isArray(v=wafConfiguration) then wafConfiguration else [wafConfiguration] } } },
      '#withZones':: d.fn(help='"Specifies a list of Availability Zones in which this Application Gateway should be located. Changing this forces a new Application Gateway to be created."', args=[d.arg(name='zones', type=d.T.array)]),
      withZones(zones): { spec+: { forProvider+: { zones: if std.isArray(v=zones) then zones else [zones] } } },
      '#withZonesMixin':: d.fn(help='"Specifies a list of Availability Zones in which this Application Gateway should be located. Changing this forces a new Application Gateway to be created."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='zones', type=d.T.array)]),
      withZonesMixin(zones): { spec+: { forProvider+: { zones+: if std.isArray(v=zones) then zones else [zones] } } },
    },
    '#providerConfigRef':: d.obj(help='"ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured."'),
    providerConfigRef: {
      '#policy':: d.obj(help='"Policies for referencing."'),
      policy: {
        '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
        withResolution(resolution): { spec+: { providerConfigRef+: { policy+: { resolution: resolution } } } },
        '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
        withResolve(resolve): { spec+: { providerConfigRef+: { policy+: { resolve: resolve } } } },
      },
      '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { providerConfigRef+: { name: name } } },
    },
    '#providerRef':: d.obj(help='"ProviderReference specifies the provider that will be used to create, observe, update, and delete this managed resource. Deprecated: Please use ProviderConfigReference, i.e. `providerConfigRef`"'),
    providerRef: {
      '#policy':: d.obj(help='"Policies for referencing."'),
      policy: {
        '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
        withResolution(resolution): { spec+: { providerRef+: { policy+: { resolution: resolution } } } },
        '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
        withResolve(resolve): { spec+: { providerRef+: { policy+: { resolve: resolve } } } },
      },
      '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { providerRef+: { name: name } } },
    },
    '#publishConnectionDetailsTo':: d.obj(help='"PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource."'),
    publishConnectionDetailsTo: {
      '#configRef':: d.obj(help='"SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret."'),
      configRef: {
        '#policy':: d.obj(help='"Policies for referencing."'),
        policy: {
          '#withResolution':: d.fn(help="\"Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.\"", args=[d.arg(name='resolution', type=d.T.string)]),
          withResolution(resolution): { spec+: { publishConnectionDetailsTo+: { configRef+: { policy+: { resolution: resolution } } } } },
          '#withResolve':: d.fn(help="\"Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.\"", args=[d.arg(name='resolve', type=d.T.string)]),
          withResolve(resolve): { spec+: { publishConnectionDetailsTo+: { configRef+: { policy+: { resolve: resolve } } } } },
        },
        '#withName':: d.fn(help='"Name of the referenced object."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { spec+: { publishConnectionDetailsTo+: { configRef+: { name: name } } } },
      },
      '#metadata':: d.obj(help='"Metadata is the metadata for connection secret."'),
      metadata: {
        '#withAnnotations':: d.fn(help='"Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as \\"metadata.annotations\\". - It is up to Secret Store implementation for others store types."', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotations(annotations): { spec+: { publishConnectionDetailsTo+: { metadata+: { annotations: annotations } } } },
        '#withAnnotationsMixin':: d.fn(help='"Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as \\"metadata.annotations\\". - It is up to Secret Store implementation for others store types."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotationsMixin(annotations): { spec+: { publishConnectionDetailsTo+: { metadata+: { annotations+: annotations } } } },
        '#withLabels':: d.fn(help='"Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as \\"metadata.labels\\". - It is up to Secret Store implementation for others store types."', args=[d.arg(name='labels', type=d.T.object)]),
        withLabels(labels): { spec+: { publishConnectionDetailsTo+: { metadata+: { labels: labels } } } },
        '#withLabelsMixin':: d.fn(help='"Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as \\"metadata.labels\\". - It is up to Secret Store implementation for others store types."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
        withLabelsMixin(labels): { spec+: { publishConnectionDetailsTo+: { metadata+: { labels+: labels } } } },
        '#withType':: d.fn(help='"Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores."', args=[d.arg(name='type', type=d.T.string)]),
        withType(type): { spec+: { publishConnectionDetailsTo+: { metadata+: { type: type } } } },
      },
      '#withName':: d.fn(help='"Name is the name of the connection secret."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { publishConnectionDetailsTo+: { name: name } } },
    },
    '#withDeletionPolicy':: d.fn(help='"DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either \\"Delete\\" or \\"Orphan\\" the external resource."', args=[d.arg(name='deletionPolicy', type=d.T.string)]),
    withDeletionPolicy(deletionPolicy): { spec+: { deletionPolicy: deletionPolicy } },
    '#writeConnectionSecretToRef':: d.obj(help='"WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other."'),
    writeConnectionSecretToRef: {
      '#withName':: d.fn(help='"Name of the secret."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { writeConnectionSecretToRef+: { name: name } } },
      '#withNamespace':: d.fn(help='"Namespace of the secret."', args=[d.arg(name='namespace', type=d.T.string)]),
      withNamespace(namespace): { spec+: { writeConnectionSecretToRef+: { namespace: namespace } } },
    },
  },
  '#mixin': 'ignore',
  mixin: self,
}
